<!DOCTYPE html>
<!--
  TimerPie
  Copyright (c) 2025 Ville Reijonen
  MIT License - https://github.com/vre/timerpie
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#f9fafb">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <title>TimerPie</title><style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    /* Custom CSS tooltips - visible on hover and keyboard focus */
    [title] {
      position: relative;
    }
    [title]:hover::after,
    [title]:focus-visible::after {
      content: attr(title);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      font-weight: normal;
      line-height: normal;
      white-space: nowrap;
      z-index: 100;
      margin-bottom: 0.25rem;
      pointer-events: none;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f9fafb;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    body.dark {
      background: #111;
    }
    body.dark .controls {
      background: rgba(30, 30, 30, 0.95);
    }
    body.dark .control-row label {
      color: #aaa;
    }
    body.dark .mode-btn {
      background: #333;
      color: #ddd;
    }
    body.dark .mode-btn.active {
      background: #3b82f6;
      color: white;
    }
    body.dark .mark-group .mode-btn {
      border-left-color: #555;
    }
    body.dark .mark-group .mode-btn:first-child {
      border-left: none;
    }
    body.dark .mark-group .mode-btn.active,
    body.dark .mark-group .mode-btn.active + .mode-btn {
      border-left-color: transparent;
    }
    body.dark .mode-group .mode-btn {
      border-left-color: #555;
    }
    body.dark .mode-group .mode-btn:first-child {
      border-left: none;
    }
    body.dark .mode-group .mode-btn.active,
    body.dark .mode-group .mode-btn.active + .mode-btn {
      border-left-color: transparent;
    }
    body.dark input {
      background: #333;
      color: #eee;
      border-color: #555;
    }
    body.dark .go-btn {
      background: #22c55e;
    }
    body.fullscreen .controls {
      display: none;
    }
    body.running .controls {
      transition: opacity 0.3s;
    }
    .fullscreen-btn {
      width: 2.5rem;
      height: 2.5rem;
      padding: 0;
      background: #e5e7eb;
      border: none;
      border-radius: 0.375rem;
      font-size: 1rem;
      cursor: pointer;
      text-align: center;
      line-height: 2.5rem;
    }
    .fullscreen-btn:hover {
      background: #d1d5db;
    }
    body.dark .fullscreen-btn {
      background: #333;
      color: #ddd;
    }
    .preset-row {
      display: flex;
      gap: 0.25rem;
      flex-wrap: wrap;
      justify-content: center;
    }
    .divider {
      width: 100%;
      height: 1px;
      background: #ddd;
    }
    body.dark .divider {
      background: #444;
    }
    .preset-btn {
      padding: 0.25rem 0.4rem;
      background: #e5e7eb;
      border: 1px solid #d1d5db;
      border-radius: 0.25rem;
      font-size: 0.7rem;
      cursor: pointer;
      transition: background 1s, color 1s, border-color 1s;
    }
    .preset-btn:hover {
      background: #d1d5db;
    }
    .preset-btn.pressed {
      background: #22c55e;
      color: white;
      border-color: #16a34a;
      transition: none;
    }
    body.dark .preset-btn {
      background: #333;
      color: #ddd;
      border-color: #555;
    }
    body.dark .preset-btn:hover {
      background: #444;
    }
    body.dark .preset-btn.pressed {
      background: #22c55e;
      color: white;
      border-color: #16a34a;
      transition: none;
    }
    .preset-group {
      display: flex;
      gap: 0;
    }
    .preset-group .preset-btn {
      border-radius: 0;
      border-left: 1px solid #d1d5db;
    }
    .preset-group .preset-btn:first-child {
      border-radius: 0.25rem 0 0 0.25rem;
      border-left: 1px solid #d1d5db;
    }
    .preset-group .preset-btn:last-child {
      border-radius: 0 0.25rem 0.25rem 0;
    }
    body.dark .preset-group .preset-btn {
      border-left-color: #555;
    }
    .exit-fullscreen {
      position: absolute;
      top: 1rem;
      left: 1rem;
      background: rgba(255,255,255,0.9);
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      cursor: pointer;
      display: none;
      z-index: 10;
    }
    body.fullscreen .exit-fullscreen {
      display: block;
    }
    body.dark .exit-fullscreen {
      background: rgba(30,30,30,0.9);
      color: #eee;
    }
    .container {
      flex: 1;
      display: flex;
      position: relative;
      min-height: 0;
    }
    .controls {
      position: absolute;
      top: 1rem;
      left: 1rem;
      background: rgba(255, 255, 255, 0.95);
      padding: 0.75rem;
      border-radius: 0.5rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .control-row {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    .control-row label {
      font-size: 0.75rem;
      color: #666;
      min-width: 3rem;
    }
    .color-dropdown {
      position: relative;
      display: inline-block;
    }
    .color-btn {
      width: 2.5rem;
      height: 2.5rem;
      border: 2px solid #000;
      border-radius: 0.375rem;
      cursor: pointer;
      transition: transform 0.2s;
    }
    .icon-btn {
      width: 2.5rem;
      height: 2.5rem;
      padding: 0;
      background: #e5e7eb;
      border: none;
      border-radius: 0.375rem;
      font-size: 1rem;
      cursor: pointer;
      text-align: center;
      line-height: 2.5rem;
    }
    .icon-btn:hover {
      background: #d1d5db;
    }
    body.dark .icon-btn {
      background: #333;
      color: #ddd;
    }
    body.dark .icon-btn:hover {
      background: #444;
    }
    .color-btn:hover {
      transform: scale(1.1);
    }
    .color-menu {
      display: none;
      position: absolute;
      top: 3.5rem;
      left: 0;
      background: white;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      padding: 0.5rem;
      z-index: 10;
      gap: 0.5rem;
      flex-wrap: wrap;
      width: 10rem;
    }
    .color-menu.show {
      display: flex;
    }
    .color-option {
      width: 2.5rem;
      height: 2.5rem;
      border: 2px solid #000;
      border-radius: 0.25rem;
      cursor: pointer;
      transition: transform 0.2s;
    }
    .color-option:hover {
      transform: scale(1.1);
    }
    .icon-group {
      display: flex;
      gap: 0.125rem;
    }
    .mark-group {
      display: flex;
      gap: 0;
    }
    .mark-group .mode-btn {
      width: 2.5rem;
      height: 2.5rem;
      padding: 0;
      border-radius: 0;
      border-left: 1px solid #d1d5db;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .mark-group .mode-btn:first-child {
      border-radius: 0.375rem 0 0 0.375rem;
      border-left: none;
    }
    .mark-group .mode-btn:last-child {
      border-radius: 0 0.375rem 0.375rem 0;
    }
    .mark-group .mode-btn.active {
      border-left-color: transparent;
    }
    .mark-group .mode-btn.active + .mode-btn {
      border-left-color: transparent;
    }
    .mode-group {
      display: flex;
      gap: 0;
    }
    .mode-group .mode-btn {
      width: 3rem;
      height: 2.5rem;
      padding: 0;
      border-radius: 0;
      border-left: 1px solid #d1d5db;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .mode-group .mode-btn:first-child {
      border-radius: 0.375rem 0 0 0.375rem;
      border-left: none;
    }
    .mode-group .mode-btn:last-child {
      border-radius: 0 0.375rem 0.375rem 0;
    }
    .mode-group .mode-btn.active {
      border-left-color: transparent;
    }
    .mode-group .mode-btn.active + .mode-btn {
      border-left-color: transparent;
    }
    .mode-btn {
      padding: 0.5rem 1rem;
      background: #e5e7eb;
      color: #374151;
      border: 2px solid transparent;
      border-radius: 0.375rem;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    .mode-btn:hover {
      background: #d1d5db;
    }
    .mode-btn.active {
      background: #3b82f6;
      color: white;
      border-color: #2563eb;
    }
    input {
      width: 5rem;
      height: 2.5rem;
      padding: 0 0.5rem;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      font-size: 1rem;
      text-align: center;
    }
    /* Focus styles for keyboard navigation */
    button:focus-visible,
    input:focus-visible {
      outline: 3px solid #3b82f6;
      outline-offset: 2px;
    }
    body.dark button:focus-visible,
    body.dark input:focus-visible {
      outline-color: #60a5fa;
    }
    .go-btn {
      height: 2.5rem;
      padding: 0 1.25rem;
      background: #22c55e;
      color: white;
      border: none;
      border-radius: 0.375rem;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }
    .go-btn:hover:not(:disabled) {
      background: #16a34a;
    }
    .go-btn:disabled {
      background: #d1d5db;
      cursor: not-allowed;
    }
    .go-btn.running {
      background: #3b82f6;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    @keyframes clock-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }
    .clock-blink-color {
      animation: clock-pulse 2s infinite;
    }
    .clock-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 0;
      padding: 1rem;
      overflow: hidden;
      position: relative;
    }
    .clock-wrapper {
      position: absolute;
      top: 50%;
      left: 50%;
    }
    #wedgeCanvas, #clock {
      position: absolute;
      top: 0;
      left: 0;
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      border: 0;
    }
    .info-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 100;
      align-items: center;
      justify-content: center;
    }
    .info-modal.show {
      display: flex;
    }
    .info-content {
      background: white;
      padding: 2rem;
      border-radius: 0.5rem;
      max-width: 20rem;
      text-align: center;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }
    .info-content h2 {
      margin: 0 0 0.5rem 0;
      font-size: 1.5rem;
    }
    .info-version {
      color: #666;
      font-size: 0.875rem;
      margin: 0 0 1rem 0;
    }
    .info-description {
      margin: 0 0 0.75rem 0;
      font-size: 0.9rem;
    }
    .info-features {
      text-align: left;
      margin: 0 0 1rem 0;
      padding-left: 1.5rem;
      font-size: 0.85rem;
    }
    .info-features li {
      margin: 0.25rem 0;
    }
    .info-subtext {
      font-size: 0.75rem;
      color: #888;
    }
    .install-instructions {
      text-align: left;
      margin: 0 0 1rem 0;
      font-size: 0.85rem;
    }
    .install-instructions dt {
      font-weight: 600;
      margin-top: 0.5rem;
    }
    .install-instructions dd {
      margin: 0.125rem 0 0 0;
      color: #666;
    }
    body.dark .info-subtext {
      color: #777;
    }
    body.dark .install-instructions dd {
      color: #999;
    }
    .install-content {
      max-width: 36rem;
    }
    .install-layout {
      display: flex;
      gap: 1.5rem;
      align-items: flex-start;
    }
    .install-qr {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.25rem;
    }
    .install-qr img {
      border-radius: 0.25rem;
    }
    .install-qr svg {
      color-scheme: light only;
    }
    .install-qr svg path[fill] {
      fill: #ffffff !important;
    }
    .install-qr svg path[stroke] {
      stroke: #000000 !important;
    }
    .info-content a {
      color: #3b82f6;
      text-decoration: none;
    }
    .info-content a:hover {
      text-decoration: underline;
    }
    .info-close {
      margin-top: 1rem;
      padding: 0.5rem 1.5rem;
      background: #e5e7eb;
      border: none;
      border-radius: 0.375rem;
      font-size: 1rem;
      cursor: pointer;
    }
    .info-close:hover {
      background: #d1d5db;
    }
    body.dark .info-content {
      background: #222;
      color: #eee;
    }
    body.dark .info-version {
      color: #999;
    }
    body.dark .info-content a {
      color: #60a5fa;
    }
    body.dark .info-close {
      background: #444;
      color: #eee;
    }
    body.dark .info-close:hover {
      background: #555;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="controls">
      <div class="control-row">
        <div class="color-dropdown">
          <button class="color-btn" id="colorBtn" title="Select clock color" aria-label="Select color" aria-expanded="false" aria-haspopup="true"></button>
          <div class="color-menu" id="colorMenu" role="menu" aria-label="Color options">
            <button class="color-option" style="background: #ff6b35;" data-color="#ff6b35" role="menuitem" aria-label="Orange"></button>
            <button class="color-option" style="background: #4a90e2;" data-color="#4a90e2" role="menuitem" aria-label="Blue"></button>
            <button class="color-option" style="background: #50c878;" data-color="#50c878" role="menuitem" aria-label="Green"></button>
            <button class="color-option" style="background: #e74c3c;" data-color="#e74c3c" role="menuitem" aria-label="Red"></button>
            <button class="color-option" style="background: #9b59b6;" data-color="#9b59b6" role="menuitem" aria-label="Purple"></button>
            <button class="color-option" style="background: #f1c40f;" data-color="#f1c40f" role="menuitem" aria-label="Yellow"></button>
          </div>
        </div>
        <button class="icon-btn" id="darkModeBtn" title="Switch to dark mode" aria-label="Switch to dark mode">üåô</button>
        <button class="icon-btn" id="displayModeBtn" title="Switch to digital display" aria-label="Switch display mode">üî¢</button>
        <span style="flex: 1;"></span>
        <span class="mark-group">
          <button class="mode-btn" data-marks="15" title="Show 15-minute labels">15</button>
          <button class="mode-btn active" data-marks="5" title="Show 5-minute labels">5</button>
          <button class="mode-btn" data-marks="0" title="Hide labels">-</button>
        </span>
      </div>
      <div class="divider"></div>
      <div class="control-row">
        <span class="mode-group">
          <button class="mode-btn" data-mode="cw" title="Clockwise mode">CW</button>
          <button class="mode-btn active" data-mode="ccw" title="Counter-clockwise mode">CCW</button>
          <button class="mode-btn" data-mode="end" title="Ending time mode">END</button>
        </span>
        <input type="text" id="time" placeholder="mins">
        <button class="go-btn" id="goBtn">Go</button>
      </div>
      <div class="preset-row">
        <span class="preset-group">
          <button class="preset-btn" data-preset="5">5</button>
          <button class="preset-btn" data-preset="10">10</button>
          <button class="preset-btn" data-preset="15">15</button>
        </span>
        <span class="preset-group">
          <button class="preset-btn" data-preset="20">20</button>
          <button class="preset-btn" data-preset="25">25</button>
          <button class="preset-btn" data-preset="30">30</button>
        </span>
        <span class="preset-group">
          <button class="preset-btn" data-preset="45">45</button>
          <button class="preset-btn" data-preset="60">60</button>
          <button class="preset-btn" data-preset="90">90</button>
        </span>
      </div>
      <div class="divider"></div>
      <div class="control-row">
        <button class="icon-btn" id="infoBtn" title="About TimerPie" aria-label="About TimerPie">‚ÑπÔ∏è</button>
        <span style="flex: 1;"></span>
        <button class="icon-btn" id="soundBtn" title="Turn alarm on" aria-label="Toggle alarm sound">üîï</button>
        <span style="flex: 1;"></span>
        <button class="fullscreen-btn" id="pipBtn" title="Picture-in-Picture mode" aria-label="Picture-in-Picture">‚ßâ</button>
        <button class="fullscreen-btn" id="fullscreenBtn" title="Go full-screen" aria-label="Toggle fullscreen">‚õ∂</button>
      </div>
    </div>
    <button class="exit-fullscreen" id="exitFullscreenBtn">Exit Fullscreen</button>
    <div class="clock-container">
      <div class="clock-wrapper" id="clockWrapper">
        <canvas id="wedgeCanvas"></canvas>
        <svg id="clock" width="480" height="460" viewBox="-15 0 480 460" role="img" aria-labelledby="clockTitle">
          <title id="clockTitle">Countdown Timer</title>
        </svg>
      </div>
    </div>
    <div id="timerStatus" role="status" aria-live="polite" class="sr-only"></div>
    <div class="info-modal" id="infoModal" role="dialog" aria-labelledby="infoTitle" aria-modal="true">
      <div class="info-content">
        <h2 id="infoTitle">TimerPie</h2>
        <p class="info-version">Version <span id="appVersion">1.0.0</span></p>
        <p class="info-description">Analog countdown timer that runs entirely in your browser.</p>
        <ul class="info-features">
          <li>Works on desktop, tablet &amp; mobile</li>
          <li>Single HTML file - save &amp; use offline</li>
          <li>Install TimerPie <a href="#" id="installLink">as App</a></li>
          <li>Keyboard: <u>Space</u> Pause/Play, <u>F</u>ullscreen, <u>P</u>ictureInPicture, <u>Esc</u></li>
        </ul>
        <p><a href="https://github.com/vre/timerpie" target="_blank" rel="noopener">github.com/vre/timerpie</a></p>
        <button class="info-close" id="infoCloseBtn">Close</button>
      </div>
    </div>
    <div class="info-modal" id="installModal" role="dialog" aria-labelledby="installTitle" aria-modal="true">
      <div class="info-content install-content">
        <h2 id="installTitle">Install as App</h2>
        <div class="install-layout">
          <dl class="install-instructions">
            <dt>Chrome (desktop)</dt>
            <dd>Install icon in address bar (üñ•Ô∏è with ‚Üì)</dd>
            <dt>Edge (desktop)</dt>
            <dd>Install icon in address bar (‚äû with +)</dd>
            <dt>Safari (Mac)</dt>
            <dd>File ‚Üí Add to Dock</dd>
            <dt>iOS / iPadOS Safari</dt>
            <dd>Share button (‚ñ¢ with ‚Üë) ‚Üí Add to Home Screen</dd>
            <dt>Android Chrome</dt>
            <dd>Menu (‚ãÆ) ‚Üí Add to home screen</dd>
            <dt>Android Firefox</dt>
            <dd>Menu (‚ãÆ) ‚Üí Add app to Home screen</dd>
          </dl>
          <div class="install-qr">
            <svg xmlns="http://www.w3.org/2000/svg" width="240" height="240" viewBox="0 0 33 33" shape-rendering="crispEdges" role="img" aria-label="QR code to TimerPie"><path fill="#ffffff" d="M0 0h33v33H0z"/><path stroke="#000000" d="M0 0.5h7m3 0h4m2 0h4m3 0h1m2 0h7M0 1.5h1m5 0h1m4 0h1m1 0h5m2 0h1m1 0h1m3 0h1m5 0h1M0 2.5h1m1 0h3m1 0h1m1 0h1m1 0h1m2 0h1m1 0h1m1 0h4m2 0h1m2 0h1m1 0h3m1 0h1M0 3.5h1m1 0h3m1 0h1m1 0h1m2 0h1m2 0h1m1 0h1m2 0h4m1 0h1m1 0h1m1 0h3m1 0h1M0 4.5h1m1 0h3m1 0h1m1 0h2m1 0h2m2 0h1m1 0h2m5 0h1m1 0h1m1 0h3m1 0h1M0 5.5h1m5 0h1m1 0h1m3 0h1m1 0h4m2 0h2m2 0h1m1 0h1m5 0h1M0 6.5h7m1 0h1m1 0h1m1 0h1m1 0h1m1 0h1m1 0h1m1 0h1m1 0h1m1 0h1m1 0h7M8 7.5h1m1 0h2m2 0h2m5 0h2M0 8.5h1m1 0h5m2 0h1m2 0h2m1 0h1m1 0h1m4 0h3m1 0h5M1 9.5h1m1 0h3m2 0h1m3 0h1m3 0h1m2 0h5m2 0h2m1 0h2m1 0h1M1 10.5h2m3 0h2m1 0h1m1 0h1m3 0h1m2 0h1m1 0h2m2 0h2m2 0h1m1 0h2M8 11.5h4m2 0h2m5 0h3m1 0h1m2 0h4M1 12.5h2m1 0h4m7 0h1m2 0h2m1 0h1m1 0h2m2 0h3m2 0h1M2 13.5h1m1 0h2m1 0h4m1 0h1m1 0h3m3 0h4m2 0h1m2 0h1m1 0h2M0 14.5h3m1 0h1m1 0h1m2 0h2m1 0h3m4 0h1m1 0h2m2 0h2m2 0h3M0 15.5h4m5 0h1m2 0h1m1 0h1m1 0h1m1 0h4m3 0h6M0 16.5h3m1 0h3m1 0h1m2 0h1m2 0h1m1 0h2m1 0h1m2 0h4m1 0h2m3 0h1M1 17.5h2m2 0h1m3 0h3m2 0h1m1 0h5m2 0h5m1 0h2m1 0h1M3 18.5h2m1 0h3m1 0h1m1 0h1m2 0h1m1 0h1m4 0h1m2 0h4m1 0h2M0 19.5h1m2 0h1m3 0h3m2 0h1m1 0h1m2 0h4m5 0h5M0 20.5h1m2 0h1m2 0h1m1 0h4m1 0h4m2 0h4m1 0h2m1 0h3m1 0h1M0 21.5h1m2 0h3m1 0h1m3 0h1m1 0h1m1 0h1m1 0h2m4 0h1m2 0h1m2 0h2m1 0h1M0 22.5h1m1 0h1m3 0h2m1 0h1m1 0h3m1 0h2m1 0h1m1 0h2m2 0h2m1 0h1m1 0h3M0 23.5h1m2 0h2m2 0h2m1 0h1m2 0h1m1 0h1m5 0h1m4 0h2m1 0h2M0 24.5h1m3 0h7m1 0h1m1 0h4m4 0h1m1 0h6m1 0h2M8 25.5h1m2 0h1m2 0h1m1 0h1m1 0h2m1 0h2m1 0h1m3 0h1m1 0h2M0 26.5h7m5 0h2m1 0h2m1 0h1m2 0h1m1 0h2m1 0h1m1 0h1m1 0h2M0 27.5h1m5 0h1m1 0h1m2 0h2m1 0h3m2 0h1m1 0h4m3 0h5M0 28.5h1m1 0h3m1 0h1m1 0h2m5 0h1m2 0h1m2 0h1m2 0h6m1 0h2M0 29.5h1m1 0h3m1 0h1m1 0h1m1 0h8m2 0h3m2 0h1m2 0h1m1 0h1m1 0h1M0 30.5h1m1 0h3m1 0h1m1 0h1m3 0h3m4 0h1m1 0h2m1 0h4M0 31.5h1m5 0h1m2 0h1m3 0h2m1 0h1m2 0h5m2 0h1m1 0h3M0 32.5h7m1 0h2m3 0h1m3 0h1m1 0h1m2 0h3m2 0h1m1 0h3"/></svg>
            <span class="info-subtext">Scan to open on mobile</span>
            <a href="https://vre.github.io/timerpie/TimerPie.html" target="_blank" rel="noopener" class="info-subtext">vre.github.io/timerpie/TimerPie.html</a>
          </div>
        </div>
        <button class="info-close" id="installCloseBtn">Close</button>
      </div>
    </div>
    <canvas id="pipCanvas" width="300" height="300" style="display:none;"></canvas>
    <video id="pipVideo" style="display:none;" muted></video>
  </div><script>
    // ============================================
    // PURE FUNCTIONS (testable, no side effects)
    // ============================================
    const darkenCache = {};
    const ClockLogic = {
      darken: function(hex, factor) {
        const key = hex + factor;
        if (darkenCache[key]) return darkenCache[key];
        const r = Math.floor(parseInt(hex.substr(1, 2), 16) * factor);
        const g = Math.floor(parseInt(hex.substr(3, 2), 16) * factor);
        const b = Math.floor(parseInt(hex.substr(5, 2), 16) * factor);
        const result = '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');
        darkenCache[key] = result;
        return result;
      },

      parseInput: function(input, mode, now, maxMinutes) {
        // Reject empty or excessively long input
        if (!input || input.length > 20) return null;

        if (mode === 'end') {
          if (input.includes(':')) {
            // Validate hh:mm format - require digits on both sides of colon
            if (!/^\d{1,2}:\d{1,2}$/.test(input)) return null;
            const parts = input.split(':').map(Number);
            const h = parts[0];
            const m = parts[1];
            if (isNaN(h) || isNaN(m) || h < 0 || h > 23 || m < 0 || m > 59) return null;

            const target = new Date(now);
            target.setHours(h, m, 0, 0);
            if (target <= now) {
              target.setDate(target.getDate() + 1);
            }

            const total = Math.min(Math.ceil((target - now) / 60000), maxMinutes);
            return { total: total, endTime: m };
          }

          const num = parseInt(input, 10);
          if (isNaN(num) || num < 0) return null;

          if (input.length >= 3 && input.length <= 4) {
            const h = Math.floor(num / 100);
            const m = num % 100;
            if (h < 0 || h > 23 || m < 0 || m > 59) return null;

            if (h < 12) {
              const amTarget = new Date(now);
              amTarget.setHours(h, m, 0, 0);
              if (amTarget <= now) amTarget.setDate(amTarget.getDate() + 1);

              const pmTarget = new Date(now);
              pmTarget.setHours(h + 12, m, 0, 0);
              if (pmTarget <= now) pmTarget.setDate(pmTarget.getDate() + 1);

              const amMins = Math.ceil((amTarget - now) / 60000);
              const pmMins = Math.ceil((pmTarget - now) / 60000);

              const amValid = amMins <= maxMinutes;
              const pmValid = pmMins <= maxMinutes;

              if (amValid && pmValid) {
                if (amMins <= pmMins) {
                  return { total: Math.min(amMins, maxMinutes), endTime: m };
                } else {
                  return { total: Math.min(pmMins, maxMinutes), endTime: m };
                }
              } else if (amValid) {
                return { total: Math.min(amMins, maxMinutes), endTime: m };
              } else if (pmValid) {
                return { total: Math.min(pmMins, maxMinutes), endTime: m };
              } else {
                if (amMins <= pmMins) {
                  return { total: Math.min(amMins, maxMinutes), endTime: m };
                } else {
                  return { total: Math.min(pmMins, maxMinutes), endTime: m };
                }
              }
            }

            const target = new Date(now);
            target.setHours(h, m, 0, 0);
            if (target <= now) {
              target.setDate(target.getDate() + 1);
            }

            const total = Math.min(Math.ceil((target - now) / 60000), maxMinutes);
            return { total: total, endTime: m };
          }

          if (num < 0 || num >= 60) return null;

          const target = new Date(now);
          target.setMinutes(num, 0, 0);
          if (target <= now) {
            target.setHours(target.getHours() + 1);
          }

          const total = Math.min(Math.ceil((target - now) / 60000), maxMinutes);
          return { total: total, endTime: num };
        }

        const mins = parseFloat(input);
        if (isNaN(mins) || mins <= 0) return null;
        return { total: Math.min(mins, maxMinutes), endTime: null };
      },

      getCircles: function(time, radius) {
        if (time > 120) {
          const outerT = time % 60 || 60;
          return [
            { r: radius.FULL, t: outerT, full: outerT === 60 },
            { r: radius.MIDDLE, t: 60, full: true },
            { r: radius.INNER, t: 60, full: true }
          ];
        }
        if (time > 60) {
          const outerT = time % 60 || 60;
          return [
            { r: radius.FULL, t: outerT, full: outerT === 60 },
            { r: radius.MIDDLE, t: 60, full: true }
          ];
        }
        if (time > 0) {
          return [{ r: radius.FULL, t: time, full: time === 60 }];
        }
        return [];
      },

      getLabelPosition: function(minute, mode, center, labelRadius) {
        let positionMinute = minute % 60;
        if (mode === 'cw') {
          positionMinute = (60 - positionMinute) % 60;
        }
        const angle = (positionMinute / 60) * 360 - 90;
        const rad = angle * Math.PI / 180;
        return {
          x: center + labelRadius * Math.cos(rad),
          y: center + labelRadius * Math.sin(rad)
        };
      },

      getCookie: function(name) {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.indexOf(name + '=') === 0) {
            try {
              return decodeURIComponent(cookie.substring(name.length + 1));
            } catch (e) {
              return null;
            }
          }
        }
        return null;
      },

      setCookie: function(name, value, days) {
        // Validate cookie name (alphanumeric, underscore, hyphen only)
        if (!/^[a-zA-Z0-9_-]+$/.test(name)) return;
        const sanitizedValue = encodeURIComponent(String(value));
        // Reject values over 4000 chars to stay within 4KB cookie limit
        if (sanitizedValue.length > 4000) return;
        let expires = '';
        if (days) {
          const date = new Date();
          date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
          expires = '; expires=' + date.toUTCString();
        }
        document.cookie = name + '=' + sanitizedValue + expires + '; path=/; SameSite=Lax';
      },

      parseHash: function() {
        const hash = window.location.hash.substring(1);
        const params = {};
        const allowedParams = ['color', 'mode', 'marks', 'dark', 'sound', 'time', 'display', 'autostart', 'controls'];
        if (hash) {
          hash.split('&').forEach(function(pair) {
            const parts = pair.split('=');
            if (parts.length === 2 && allowedParams.indexOf(parts[0]) !== -1) {
              params[parts[0]] = decodeURIComponent(parts[1]);
            }
          });
        }
        return params;
      },

      updateHash: function(state) {
        const params = [];
        if (state.color && state.color !== '#ff6b35') {
          params.push('color=' + state.color.substring(1));
        }
        if (state.mode && state.mode !== 'ccw') {
          params.push('mode=' + state.mode);
        }
        if (state.marks !== undefined && state.marks !== 15) {
          params.push('marks=' + state.marks);
        }
        if (document.body.classList.contains('dark')) {
          params.push('dark=1');
        }
        if (state.sound === true) {
          params.push('sound=on');
        }
        if (state.displayMode === 'digital') {
          params.push('display=digital');
        }
        if (state.timeValue) {
          params.push('time=' + encodeURIComponent(state.timeValue));
        }
        const hash = params.length > 0 ? '#' + params.join('&') : '';
        history.replaceState(null, '', window.location.pathname + hash);
      },

      // Generate a WAV beep as base64 data URI (works better in background than Web Audio API)
      generateBeepDataUri: function() {
        const sampleRate = 44100;
        const duration = 0.75;
        const frequency1 = 220; // A3
        const frequency2 = 277; // C#4
        const numSamples = Math.floor(sampleRate * duration);

        // WAV header
        const buffer = new ArrayBuffer(44 + numSamples * 2);
        const view = new DataView(buffer);

        // RIFF header
        const writeString = function(offset, str) {
          for (let i = 0; i < str.length; i++) {
            view.setUint8(offset + i, str.charCodeAt(i));
          }
        };
        writeString(0, 'RIFF');
        view.setUint32(4, 36 + numSamples * 2, true);
        writeString(8, 'WAVE');
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true); // chunk size
        view.setUint16(20, 1, true); // PCM
        view.setUint16(22, 1, true); // mono
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * 2, true); // byte rate
        view.setUint16(32, 2, true); // block align
        view.setUint16(34, 16, true); // bits per sample
        writeString(36, 'data');
        view.setUint32(40, numSamples * 2, true);

        // Generate samples with envelope
        for (let i = 0; i < numSamples; i++) {
          const t = i / sampleRate;
          // ADSR envelope
          let env;
          if (t < 0.04) env = t / 0.04; // attack
          else if (t < 0.6) env = 1.0; // sustain
          else env = Math.max(0, 1 - (t - 0.6) / 0.15); // release

          // Two sine waves mixed
          let sample = Math.sin(2 * Math.PI * frequency1 * t) * 0.3 +
                       Math.sin(2 * Math.PI * frequency2 * t) * 0.15;
          sample *= env;

          // Convert to 16-bit PCM
          const pcm = Math.max(-32768, Math.min(32767, Math.floor(sample * 32767)));
          view.setInt16(44 + i * 2, pcm, true);
        }

        // Convert to base64
        let binary = '';
        const bytes = new Uint8Array(buffer);
        for (let i = 0; i < bytes.length; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return 'data:audio/wav;base64,' + btoa(binary);
      },

      // Cached beep data URI
      beepDataUri: null,

      // Play alarm using HTML5 Audio element (better background support than Web Audio API)
      playAlarm: function(state) {
        if (!state.sound) return null;

        const handle = { audios: [], timeout: null, notifications: [], retryTimeout: null };
        const self = this;

        // Build absolute icon URL for reliability
        const iconUrl = window.location.href.replace(/[^/]*$/, '') + 'icons/icon-192.png';

        // Show system notification for background tabs
        function showNotification(tag, body) {
          if ('Notification' in window && Notification.permission === 'granted') {
            try {
              const notif = new Notification('Timer Complete', {
                body: body,
                icon: iconUrl,
                tag: tag,
                requireInteraction: true,
                silent: false
              });
              handle.notifications.push(notif);
              return notif;
            } catch (e) {}
          }
          return null;
        }

        showNotification('tasktimer-alarm', 'Your timer has finished!');

        // Retry notification after 3 seconds if document still hidden
        handle.retryTimeout = setTimeout(function() {
          if (document.hidden) {
            showNotification('tasktimer-alarm-retry', 'Timer waiting - click to view');
          }
        }, 3000);

        // Set dock badge (works on macOS PWA)
        if ('setAppBadge' in navigator) {
          navigator.setAppBadge(1).catch(function() {});
        }

        // Vibrate on mobile (pattern matches beep timing: 750ms on, 375ms off, repeat 3x)
        if ('vibrate' in navigator) {
          navigator.vibrate([750, 375, 750, 375, 750]);
        }

        // Generate beep sound (cached)
        if (!this.beepDataUri) {
          this.beepDataUri = this.generateBeepDataUri();
        }

        // Play 3 beeps using Audio elements
        let beepCount = 0;
        const playBeep = function() {
          if (beepCount >= 3) return;
          const audio = new Audio(self.beepDataUri);
          audio.volume = 1.0;
          handle.audios.push(audio);
          audio.play().catch(function() {});
          beepCount++;
          if (beepCount < 3) {
            handle.timeout = setTimeout(playBeep, 1125);
          }
        };

        playBeep();
        return handle;
      },

      stopAlarm: function(alarmHandle) {
        if (alarmHandle) {
          if (alarmHandle.timeout) clearTimeout(alarmHandle.timeout);
          if (alarmHandle.retryTimeout) clearTimeout(alarmHandle.retryTimeout);
          if (alarmHandle.audios) {
            alarmHandle.audios.forEach(function(a) { a.pause(); });
          }
          if (alarmHandle.notifications) {
            alarmHandle.notifications.forEach(function(n) { n.close(); });
          }
          // Clear dock badge
          if ('clearAppBadge' in navigator) {
            navigator.clearAppBadge().catch(function() {});
          }
        }
      },

      // Request notification permission (only once per session)
      notificationRequested: false,
      requestNotificationPermission: function() {
        if (this.notificationRequested) return;
        if ('Notification' in window && Notification.permission === 'default') {
          this.notificationRequested = true;
          Notification.requestPermission();
        }
      },

      // Wake Lock API - keeps screen on while timer runs
      wakeLock: null,

      requestWakeLock: async function() {
        if ('wakeLock' in navigator) {
          // Release existing lock first to prevent listener accumulation
          if (this.wakeLock) {
            try {
              this.wakeLock.release();
            } catch (e) {}
            this.wakeLock = null;
          }
          try {
            this.wakeLock = await navigator.wakeLock.request('screen');
            // Handle automatic release by browser (e.g., tab hidden, low battery)
            const self = this;
            this.wakeLock.addEventListener('release', function() {
              self.wakeLock = null;
            }, { once: true }); // Use once: true to auto-remove listener
          } catch (e) {
            // Wake lock request failed (e.g., low battery, tab not visible)
            this.wakeLock = null;
          }
        }
      },

      releaseWakeLock: function() {
        if (this.wakeLock) {
          this.wakeLock.release();
          this.wakeLock = null;
        }
      },

      // Canvas rendering - pure functions for angle calculations
      getTimerEndAngle: function(timerCircle, mode, endTime, now) {
        if (mode === 'end') {
          const curMin = now.getMinutes() + now.getSeconds() / 60;
          return (curMin / 60) * 360 - 90;
        }
        if (mode === 'cw') {
          return ((60 - timerCircle.t) / 60) * 360 - 90;
        }
        return (timerCircle.t / 60) * 360 - 90;
      },

      getWedgeAngles: function(circle, timerEnd, mode, endTime, now) {
        if (circle.full) {
          return { start: timerEnd, end: timerEnd + 360 };
        }
        if (mode === 'end') {
          const curMin = now.getMinutes() + now.getSeconds() / 60;
          const start = (curMin / 60) * 360 - 90;
          let end = (endTime / 60) * 360 - 90;
          if (end < start) end += 360;
          return { start: start, end: end };
        }
        if (mode === 'cw') {
          return { start: ((60 - circle.t) / 60) * 360 - 90, end: -90 };
        }
        return { start: -90, end: (circle.t / 60) * 360 - 90 };
      },

      // Render wedges to canvas context
      renderWedgesToCanvas: function(ctx, width, height, circles, mode, color, running, displayMode, endTime, now, center, isDark) {
        const self = this;
        ctx.clearRect(-15, 0, width, height); // viewBox starts at -15
        if (circles.length === 0) return;

        const timerEnd = this.getTimerEndAngle(circles[0], mode, endTime, now);
        const opacity = running ? 1 : 0.2;
        const numCircles = circles.length;
        const RING_ZONE_WIDTH = 60;
        const RING_GAP = 2;
        const RING_ZONE_OUTER = 180;
        const DARKEN = { MIDDLE: 0.7, INNER: 0.5 };
        const RADIUS = { INNER: 60 };

        const ringWidth = displayMode === 'digital'
          ? (RING_ZONE_WIDTH - (numCircles - 1) * RING_GAP) / numCircles
          : undefined;

        for (let i = 0; i < circles.length; i++) {
          const c = circles[i];
          let radius = c.r;

          // Digital mode: override radius to fit in outer 1/3 zone
          if (displayMode === 'digital') {
            radius = RING_ZONE_OUTER - i * (ringWidth + RING_GAP);
          }

          const angles = this.getWedgeAngles(c, timerEnd, mode, endTime, now);
          const colorFactor = displayMode === 'digital'
            ? (i === 0 ? 0.85 : (i === 1 ? DARKEN.MIDDLE : DARKEN.INNER))
            : (c.r === RADIUS.INNER ? DARKEN.INNER : DARKEN.MIDDLE);
          const fillColor = c.full ? this.darken(color, colorFactor) : color;

          ctx.save();
          ctx.globalAlpha = opacity;
          ctx.fillStyle = fillColor;
          ctx.strokeStyle = fillColor;
          ctx.lineWidth = 2;

          const startRad = angles.start * Math.PI / 180;
          const endRad = angles.end * Math.PI / 180;
          const innerR = displayMode === 'digital' ? radius - ringWidth : 0;

          if (c.full) {
            // Full circle/donut
            ctx.beginPath();
            if (displayMode === 'digital') {
              // Donut shape
              ctx.arc(center, center, radius, 0, Math.PI * 2);
              ctx.arc(center, center, innerR, 0, Math.PI * 2, true);
            } else {
              // Full circle
              ctx.arc(center, center, radius, 0, Math.PI * 2);
            }
            ctx.fill();
            ctx.stroke();

            // Edge line
            ctx.beginPath();
            const edgeX = center + radius * Math.cos(startRad);
            const edgeY = center + radius * Math.sin(startRad);
            if (displayMode === 'digital') {
              ctx.moveTo(center + innerR * Math.cos(startRad), center + innerR * Math.sin(startRad));
            } else {
              ctx.moveTo(center, center);
            }
            ctx.lineTo(edgeX, edgeY);
            ctx.stroke();
          } else {
            // Partial wedge
            ctx.beginPath();
            if (displayMode === 'digital') {
              // Ring arc
              ctx.arc(center, center, radius, startRad, endRad);
              ctx.arc(center, center, innerR, endRad, startRad, true);
              ctx.closePath();
            } else {
              // Pie wedge
              ctx.moveTo(center, center);
              ctx.arc(center, center, radius, startRad, endRad);
              ctx.closePath();
            }
            ctx.fill();
            ctx.stroke();

            // Moving edge line
            const movingRad = mode === 'ccw' ? endRad : startRad;
            const movingX = center + radius * Math.cos(movingRad);
            const movingY = center + radius * Math.sin(movingRad);
            ctx.beginPath();
            ctx.strokeStyle = isDark ? '#fff' : '#000';
            if (displayMode === 'digital') {
              ctx.moveTo(center + innerR * Math.cos(movingRad), center + innerR * Math.sin(movingRad));
            } else {
              ctx.moveTo(center, center);
            }
            ctx.lineTo(movingX, movingY);
            ctx.stroke();
          }
          ctx.restore();
        }
      }
    };

    // Expose for testing
    if (typeof window !== 'undefined') {
      window.ClockLogic = ClockLogic;
    }

    // ============================================
    // BACKGROUND TIMER WORKER
    // Web Workers are NOT throttled in background tabs
    // ============================================
    var timerWorker = null;
    try {
      var workerCode = [
        'var endTime = null;',
        'self.onmessage = function(e) {',
        '  if (e.data.type === "start") endTime = e.data.endTime;',
        '  else if (e.data.type === "stop") endTime = null;',
        '};',
        'setInterval(function() {',
        '  if (endTime && Date.now() >= endTime) {',
        '    self.postMessage({ type: "complete" });',
        '    endTime = null;',
        '  }',
        '}, 100);' // Check every 100ms for better accuracy
      ].join('\n');
      var blob = new Blob([workerCode], { type: 'application/javascript' });
      var blobUrl = URL.createObjectURL(blob);
      timerWorker = new Worker(blobUrl);
      URL.revokeObjectURL(blobUrl); // Revoke immediately after worker creation to prevent memory leak
    } catch (e) {
      // Web Worker not available (e.g., file:// protocol) - fallback to main thread
      timerWorker = null;
    }

    // Beep audio is lazy-generated on first alarm (saves ~66KB base64 work on load)

    // Handle worker completion message (runs even in background tabs)
    function handleWorkerComplete() {
      if (!state.running || state.completed) return;
      state.remaining = 0;
      state.running = false;
      state.paused = false;
      ClockLogic.releaseWakeLock();
      document.body.classList.remove('running');
      if (el.goBtn) {
        el.goBtn.classList.remove('running');
        el.goBtn.textContent = 'Go';
        el.goBtn.title = 'Start the timer';
        el.goBtn.disabled = false;
      }
      if (state.animFrame !== null) {
        cancelAnimationFrame(state.animFrame);
        state.animFrame = null;
      }
      // Trigger alarm - this is the critical part for background notification
      if (typeof startCompletionBlink === 'function') {
        startCompletionBlink();
      }
      if (typeof updateTitle === 'function') {
        updateTitle();
      }
    }

    if (timerWorker) {
      timerWorker.onmessage = function(e) {
        if (e.data.type === 'complete') {
          handleWorkerComplete();
        }
      };
    }

    // ============================================
    // APPLICATION CONSTANTS
    // ============================================
    const RADIUS = { FULL: 180, MIDDLE: 120, INNER: 60 };
    // Digital mode: ALL rings fit in outer 1/3 zone (180‚Üí120)
    const RING_ZONE_OUTER = 180;
    const RING_ZONE_WIDTH = 60;
    const RING_GAP = 2;
    const CENTER = 225;
    const DARKEN = { MIDDLE: 0.7, INNER: 0.5 };
    const TICK = { MAJOR_LENGTH: 15, MINOR_LENGTH: 8, OUTER_OFFSET: 5, LABEL_OFFSET: 35 };
    const PREVIEW_DIM = 0.2;
    const MAX_MINUTES = 180;

    // ============================================
    // APPLICATION STATE
    // ============================================
    const state = {
      color: '#ff6b35',
      mode: 'ccw',
      marks: 5,
      sound: false,
      displayMode: 'analog',
      timeValue: '',
      total: 0,
      remaining: 0,
      running: false,
      paused: false,
      completed: false,
      startTime: null,
      endTime: null,
      animFrame: null,
      previewFrame: null,
      alarmInterval: null,
      completionTime: null,
      overtimeInterval: null
    };
    window.state = state; // Expose for testing

    const el = {
      colorBtn: document.getElementById('colorBtn'),
      colorMenu: document.getElementById('colorMenu'),
      colorOpts: document.querySelectorAll('.color-option'),
      modeBtns: document.querySelectorAll('[data-mode]'),
      markBtns: document.querySelectorAll('[data-marks]'),
      timeInput: document.getElementById('time'),
      goBtn: document.getElementById('goBtn'),
      svg: document.getElementById('clock'),
      wedgeCanvas: document.getElementById('wedgeCanvas'),
      darkModeBtn: document.getElementById('darkModeBtn'),
      soundBtn: document.getElementById('soundBtn'),
      displayModeBtn: document.getElementById('displayModeBtn'),
      fullscreenBtn: document.getElementById('fullscreenBtn'),
      exitFullscreenBtn: document.getElementById('exitFullscreenBtn'),
      pipBtn: document.getElementById('pipBtn'),
      pipCanvas: document.getElementById('pipCanvas'),
      pipVideo: document.getElementById('pipVideo'),
      infoBtn: document.getElementById('infoBtn'),
      infoModal: document.getElementById('infoModal'),
      infoCloseBtn: document.getElementById('infoCloseBtn'),
      installLink: document.getElementById('installLink'),
      installModal: document.getElementById('installModal'),
      installCloseBtn: document.getElementById('installCloseBtn')
    };
    const wedgeCtx = el.wedgeCanvas ? el.wedgeCanvas.getContext('2d') : null;

    // Canvas and clock wrapper setup
    const clockWrapper = document.getElementById('clockWrapper');
    let canvasScale = 1;

    function resizeClockWrapper() {
      if (!clockWrapper) return;
      const container = clockWrapper.parentElement;
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;

      // SVG viewBox is 480x460 (starts at -15), calculate scale to fit container
      const scaleX = containerWidth / 480;
      const scaleY = containerHeight / 460;
      const scale = Math.min(scaleX, scaleY);
      canvasScale = scale;

      // Size wrapper to scaled dimensions
      const scaledWidth = 480 * scale;
      const scaledHeight = 460 * scale;
      clockWrapper.style.width = scaledWidth + 'px';
      clockWrapper.style.height = scaledHeight + 'px';
      clockWrapper.style.transform = 'translate(-50%, -50%)';

      // Canvas renders at full display resolution for crisp edges
      if (el.wedgeCanvas && wedgeCtx) {
        const dpr = window.devicePixelRatio || 1;
        el.wedgeCanvas.width = scaledWidth * dpr;
        el.wedgeCanvas.height = scaledHeight * dpr;
        el.wedgeCanvas.style.width = scaledWidth + 'px';
        el.wedgeCanvas.style.height = scaledHeight + 'px';
        // Scale context to draw in SVG viewBox coordinates (viewBox starts at -15)
        wedgeCtx.setTransform(scale * dpr, 0, 0, scale * dpr, 15 * scale * dpr, 0);
      }

      // SVG scales via CSS (vector graphics stay crisp)
      if (el.svg) {
        el.svg.style.width = scaledWidth + 'px';
        el.svg.style.height = scaledHeight + 'px';
      }
    }

    resizeClockWrapper();
    window.addEventListener('resize', function() {
      resizeClockWrapper();
      // Redraw canvas after resize (render defined later, called via reference)
      if (typeof render === 'function') render();
    });

    // Create layers for static face, dynamic wedges, and center timer text
    const faceLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const wedgeLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const timerText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    timerText.setAttribute('x', CENTER);
    timerText.setAttribute('y', CENTER);
    timerText.setAttribute('text-anchor', 'middle');
    timerText.setAttribute('dominant-baseline', 'central');
    timerText.setAttribute('font-size', '48');
    timerText.setAttribute('font-weight', 'bold');
    timerText.setAttribute('font-family', "'SF Mono', 'Menlo', 'Consolas', 'Liberation Mono', monospace");
    el.svg.appendChild(faceLayer);
    el.svg.appendChild(wedgeLayer);
    el.svg.appendChild(timerText);

    // ============================================
    // APP WRAPPERS (use pure functions with app state)
    // ============================================
    function darken(hex, factor) {
      return ClockLogic.darken(hex, factor);
    }

    function parseInput(input) {
      return ClockLogic.parseInput(input, state.mode, new Date(), MAX_MINUTES);
    }

    function getCircles(time) {
      return ClockLogic.getCircles(time, RADIUS);
    }

    function getLabelPosition(minute) {
      return ClockLogic.getLabelPosition(minute, state.mode, CENTER, RADIUS.FULL + TICK.LABEL_OFFSET);
    }

    function createLabel(minute, fontSize) {
      const pos = getLabelPosition(minute);
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', pos.x);
      text.setAttribute('y', pos.y);
      text.setAttribute('text-anchor', 'middle');
      text.setAttribute('dominant-baseline', 'central');
      text.setAttribute('font-size', fontSize);
      text.setAttribute('font-weight', 'bold');
      text.setAttribute('fill', document.body.classList.contains('dark') ? '#eee' : '#333');
      text.textContent = minute;
      return text;
    }

    function createClockFace() {
      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');

      for (let i = 0; i < 60; i++) {
        const angle = (i / 60) * 360 - 90;
        const rad = angle * Math.PI / 180;
        const quarter = i % 15 === 0; // 0, 15, 30, 45
        const major = i % 5 === 0;
        const outer = RADIUS.FULL + TICK.OUTER_OFFSET;
        const inner = outer - (major ? TICK.MAJOR_LENGTH : TICK.MINOR_LENGTH);

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', CENTER + outer * Math.cos(rad));
        line.setAttribute('y1', CENTER + outer * Math.sin(rad));
        line.setAttribute('x2', CENTER + inner * Math.cos(rad));
        line.setAttribute('y2', CENTER + inner * Math.sin(rad));
        line.setAttribute('stroke', document.body.classList.contains('dark') ? '#eee' : '#333');
        line.setAttribute('stroke-width', quarter ? 5 : (major ? 3 : 1));
        g.appendChild(line);
      }

      if (state.marks === 15) {
        [15, 30, 45, 60].forEach(function(m) {
          g.appendChild(createLabel(m, '20'));
        });
      } else if (state.marks === 5) {
        for (let m = 5; m <= 60; m += 5) {
          g.appendChild(createLabel(m, '16'));
        }
      }

      return g;
    }

    function initClockFace() {
      faceLayer.innerHTML = '';
      faceLayer.appendChild(createClockFace());
    }

    function updateTimerText() {
      const isDark = document.body.classList.contains('dark');
      timerText.setAttribute('fill', isDark ? '#eee' : '#333');

      // Only show timer text in digital mode
      if (state.displayMode !== 'digital') {
        timerText.textContent = '';
        return;
      }

      if (state.remaining <= 0) {
        timerText.textContent = '';
        return;
      }

      const mins = Math.floor(state.remaining);
      const secs = Math.round((state.remaining - mins) * 60);
      // Handle edge case where rounding gives 60 seconds
      const displayMins = secs >= 60 ? mins + 1 : mins;
      const displaySecs = secs >= 60 ? 0 : secs;
      timerText.textContent = displayMins + ':' + (displaySecs < 10 ? '0' : '') + displaySecs;
    }

    function updateOvertimeText() {
      if (!state.completed || state.displayMode !== 'digital') return;
      const isDark = document.body.classList.contains('dark');
      timerText.setAttribute('fill', '#fff'); // White on colored background

      const elapsedMs = Date.now() - state.completionTime;
      const elapsedSecs = Math.floor(elapsedMs / 1000);
      const mins = Math.floor(elapsedSecs / 60);
      const secs = elapsedSecs % 60;
      timerText.textContent = '-' + mins + ':' + (secs < 10 ? '0' : '') + secs;
    }

    function render() {
      const circles = getCircles(state.remaining);

      // Render wedges to canvas using SVG viewBox coordinates
      if (wedgeCtx && el.wedgeCanvas) {
        ClockLogic.renderWedgesToCanvas(
          wedgeCtx,
          480, // SVG viewBox width
          460, // SVG viewBox height
          circles,
          state.mode,
          state.color,
          state.running,
          state.displayMode,
          state.endTime,
          new Date(),
          CENTER,
          document.body.classList.contains('dark')
        );
      }

      // Clear SVG wedge layer (no longer used for rendering, kept for compatibility)
      wedgeLayer.innerHTML = '';

      if (circles.length === 0) {
        // Clear timer text when no circles
        if (state.displayMode === 'digital') {
          timerText.textContent = '';
        }
        return;
      }

      // Update center timer text (digital mode only)
      updateTimerText();
    }

    function startCompletionBlink() {
      state.completed = true;
      state.completionTime = Date.now();
      state.alarmHandle = ClockLogic.playAlarm(state);
      wedgeLayer.innerHTML = '';

      // Announce completion to screen readers
      document.getElementById('timerStatus').textContent = 'Timer completed!';

      const isDark = document.body.classList.contains('dark');

      if (state.displayMode === 'digital') {
        // Digital mode: static colored center + pulsing ring + overtime counter

        // Create static colored center circle (inner 2/3)
        const centerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        centerCircle.setAttribute('cx', CENTER);
        centerCircle.setAttribute('cy', CENTER);
        centerCircle.setAttribute('r', RING_ZONE_OUTER - RING_ZONE_WIDTH); // Inner edge = 120
        centerCircle.setAttribute('fill', state.color);
        wedgeLayer.appendChild(centerCircle);

        // Create pulsing ring (outer 1/3 zone) using a donut shape
        const outerR = RING_ZONE_OUTER;
        const innerR = RING_ZONE_OUTER - RING_ZONE_WIDTH;
        const ring = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const d = [
          'M', CENTER + outerR, CENTER,
          'A', outerR, outerR, 0, 1, 1, CENTER - outerR, CENTER,
          'A', outerR, outerR, 0, 1, 1, CENTER + outerR, CENTER,
          'M', CENTER + innerR, CENTER,
          'A', innerR, innerR, 0, 1, 0, CENTER - innerR, CENTER,
          'A', innerR, innerR, 0, 1, 0, CENTER + innerR, CENTER,
          'Z'
        ].join(' ');
        ring.setAttribute('d', d);
        ring.setAttribute('fill', state.color);
        ring.setAttribute('fill-rule', 'evenodd');
        ring.setAttribute('class', 'clock-blink-color');
        wedgeLayer.appendChild(ring);

        // Start overtime counter
        updateOvertimeText();
        state.overtimeInterval = setInterval(updateOvertimeText, 1000);
      } else {
        // Analog mode: full circle pulses

        // Create background circle (white in light mode, black in dark mode)
        const bgCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        bgCircle.setAttribute('cx', CENTER);
        bgCircle.setAttribute('cy', CENTER);
        bgCircle.setAttribute('r', RADIUS.FULL);
        bgCircle.setAttribute('fill', isDark ? '#111' : 'white');
        bgCircle.setAttribute('stroke', isDark ? '#eee' : '#000');
        bgCircle.setAttribute('stroke-width', '2');
        wedgeLayer.appendChild(bgCircle);

        // Create colored circle on top with pulse animation
        const colorCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        colorCircle.setAttribute('cx', CENTER);
        colorCircle.setAttribute('cy', CENTER);
        colorCircle.setAttribute('r', RADIUS.FULL);
        colorCircle.setAttribute('fill', state.color);
        colorCircle.setAttribute('class', 'clock-blink-color');
        wedgeLayer.appendChild(colorCircle);
      }
    }

    function stopCompletionBlink() {
      // Always clean up interval defensively (prevents leaks if state.completed is wrong)
      if (state.overtimeInterval) {
        clearInterval(state.overtimeInterval);
        state.overtimeInterval = null;
      }
      if (state.completed) {
        state.completed = false;
        ClockLogic.stopAlarm(state.alarmHandle);
        state.alarmHandle = null;
        timerText.textContent = '';
        wedgeLayer.innerHTML = '';
      }
    }

    var lastAnnouncedMin = -1;
    function updateTitle() {
      if (state.running || state.paused) {
        var mins = Math.floor(state.remaining);
        var secs = Math.round((state.remaining - mins) * 60);
        if (secs >= 60) { mins++; secs = 0; }
        const timeStr = mins + ':' + (secs < 10 ? '0' : '') + secs;
        document.title = timeStr + ' - TimerPie';
        // Update ARIA live region once per minute to avoid overwhelming screen readers
        if (mins !== lastAnnouncedMin) {
          lastAnnouncedMin = mins;
          document.getElementById('timerStatus').textContent = mins + ' minute' + (mins !== 1 ? 's' : '') + ' remaining';
        }
      } else {
        document.title = 'TimerPie';
        lastAnnouncedMin = -1;
        document.getElementById('timerStatus').textContent = '';
      }
    }

    function animate() {
      const elapsed = (Date.now() - state.startTime) / 60000;
      state.remaining = Math.max(0, state.total - elapsed);

      // In END mode, also check if current time has reached end time
      // Only check when remaining is small (< 2 min) to avoid false positives from mode switching
      if (state.mode === 'end' && state.endTime !== null && state.remaining < 2) {
        const now = new Date();
        const curMin = now.getMinutes() + now.getSeconds() / 60;
        // Check if we've reached or passed the end time
        // Handle hour rollover: if endTime > 30 and curMin < 30, we've rolled over to next hour
        const reachedEndTime = curMin >= state.endTime ||
          (state.endTime > 30 && curMin < 30);
        if (reachedEndTime) {
          state.remaining = 0;
        }
      }

      if (state.remaining <= 0) {
        state.running = false;
        state.paused = false;
        ClockLogic.releaseWakeLock();
        if (timerWorker) timerWorker.postMessage({ type: 'stop' });
        document.body.classList.remove('running');
        el.goBtn.classList.remove('running');
        el.goBtn.textContent = 'Go';
        el.goBtn.title = 'Start the timer';
        // Enable Go button if input has valid value so user can restart
        var parsed = parseInput(el.timeInput.value.trim());
        el.goBtn.disabled = !parsed || !parsed.total;
        updateTitle();
        startCompletionBlink();
        return;
      }

      updateTitle();
      state.animFrame = requestAnimationFrame(animate);
      render();
    }

    function previewAnimate() {
      if (state.running || state.mode !== 'end') {
        state.previewFrame = null;
        return;
      }

      const input = el.timeInput.value.trim();
      if (!input) {
        state.previewFrame = null;
        return;
      }

      const parsed = parseInput(input);
      if (parsed) {
        state.total = parsed.total;
        state.remaining = parsed.total;
        state.endTime = parsed.endTime;
        render();
        state.previewFrame = requestAnimationFrame(previewAnimate);
      } else {
        state.previewFrame = null;
      }
    }

    function stopPreviewAnimation() {
      if (state.previewFrame !== null) {
        cancelAnimationFrame(state.previewFrame);
        state.previewFrame = null;
      }
    }

    function startPreviewAnimation() {
      stopPreviewAnimation();
      if (state.mode === 'end' && !state.running) {
        state.previewFrame = requestAnimationFrame(previewAnimate);
      }
    }

    function start() {
      // Guard against multiple simultaneous starts (race condition)
      if (state.running) return;

      const input = el.timeInput.value.trim();
      if (!input) return;

      const parsed = parseInput(input);
      if (!parsed) return;

      // Stop completion blink if active
      stopCompletionBlink();

      // Cancel preview animation
      stopPreviewAnimation();

      // Cancel any existing animation frame to prevent memory leak
      if (state.animFrame !== null) {
        cancelAnimationFrame(state.animFrame);
        state.animFrame = null;
      }

      // Update input field in END mode to show full hh:mm
      if (state.mode === 'end' && !input.includes(':')) {
        // Input was short format (1-4 digits), show full end time
        const endDate = new Date(Date.now() + parsed.total * 60000);
        const h = endDate.getHours();
        const m = endDate.getMinutes();
        el.timeInput.value = h + ':' + (m < 10 ? '0' : '') + m;
      } else if (parsed.total === 180) {
        // Time was capped at max
        if (state.mode === 'end') {
          const endDate = new Date(Date.now() + 180 * 60000);
          const h = endDate.getHours();
          const m = endDate.getMinutes();
          el.timeInput.value = h + ':' + (m < 10 ? '0' : '') + m;
        } else {
          // CCW/CW: check if original input was > 180
          const originalMins = parseFloat(input);
          if (!isNaN(originalMins) && originalMins > 180) {
            el.timeInput.value = '180';
          }
        }
      }

      state.total = parsed.total;
      state.remaining = parsed.total;
      state.startTime = Date.now();

      // Calculate endTime (minute on clock) for mode switching support
      if (parsed.endTime !== null) {
        state.endTime = parsed.endTime;
      } else {
        // Calculate end minute from current time + total minutes
        const endDate = new Date(state.startTime + parsed.total * 60000);
        const endMinute = endDate.getMinutes() + endDate.getSeconds() / 60;
        state.endTime = endMinute;
      }

      state.running = true;
      state.paused = false;
      ClockLogic.requestWakeLock();

      // Start background worker for reliable completion detection
      if (timerWorker) {
        timerWorker.postMessage({
          type: 'start',
          endTime: state.startTime + parsed.total * 60000
        });
      }

      el.goBtn.classList.add('running');
      document.body.classList.add('running');
      if (state.mode === 'end') {
        // No pause in END mode - target time is fixed
        el.goBtn.disabled = true;
      } else {
        el.goBtn.textContent = 'Pause';
        el.goBtn.title = 'Pause the timer';
      }
      animate();
    }

    function pause() {
      if (!state.running || state.paused) return;
      state.paused = true;
      state.running = false;
      ClockLogic.releaseWakeLock();
      if (timerWorker) timerWorker.postMessage({ type: 'stop' });
      document.body.classList.remove('running');
      if (state.animFrame !== null) {
        cancelAnimationFrame(state.animFrame);
        state.animFrame = null;
      }
      el.goBtn.classList.remove('running');
      el.goBtn.textContent = 'Play';
      el.goBtn.title = 'Resume timer';
      document.getElementById('timerStatus').textContent = 'Timer paused';
      updateTitle();
    }

    function resume() {
      if (!state.paused) return;
      state.paused = false;
      state.running = true;
      ClockLogic.requestWakeLock();
      document.body.classList.add('running');
      state.startTime = Date.now() - (state.total - state.remaining) * 60000;
      el.goBtn.classList.add('running');
      el.goBtn.textContent = 'Pause';
      el.goBtn.title = 'Pause the timer';
      document.getElementById('timerStatus').textContent = 'Timer resumed';
      animate();
    }

    function handleGoClick() {
      if (state.running) {
        pause();
      } else if (state.paused) {
        resume();
      } else {
        start();
      }
    }

    el.colorBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      const isOpen = el.colorMenu.classList.toggle('show');
      el.colorBtn.setAttribute('aria-expanded', isOpen);
      if (isOpen) {
        el.colorOpts[0].focus();
      }
    });

    // Keyboard navigation for color menu
    el.colorBtn.addEventListener('keydown', function(e) {
      if (e.key === 'ArrowDown' || e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        el.colorMenu.classList.add('show');
        el.colorBtn.setAttribute('aria-expanded', 'true');
        el.colorOpts[0].focus();
      }
    });

    el.colorMenu.addEventListener('keydown', function(e) {
      var opts = el.colorOpts;
      var current = document.activeElement;
      var idx = Array.prototype.indexOf.call(opts, current);

      if (e.key === 'ArrowDown') {
        e.preventDefault();
        opts[(idx + 1) % opts.length].focus();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        opts[(idx - 1 + opts.length) % opts.length].focus();
      } else if (e.key === 'Escape') {
        e.preventDefault();
        el.colorMenu.classList.remove('show');
        el.colorBtn.setAttribute('aria-expanded', 'false');
        el.colorBtn.focus();
      } else if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        if (current.classList.contains('color-option')) {
          current.click();
        }
      }
    });

    document.addEventListener('click', function() {
      el.colorMenu.classList.remove('show');
      el.colorBtn.setAttribute('aria-expanded', 'false');
    });

    for (let i = 0; i < el.colorOpts.length; i++) {
      el.colorOpts[i].setAttribute('tabindex', '0');
      el.colorOpts[i].setAttribute('role', 'menuitem');
      el.colorOpts[i].addEventListener('click', function(e) {
        e.stopPropagation();
        state.color = this.dataset.color;
        el.colorBtn.style.background = state.color;
        el.colorMenu.classList.remove('show');
        el.colorBtn.setAttribute('aria-expanded', 'false');
        el.colorBtn.focus();
        ClockLogic.setCookie('clockColor', state.color, 365);
        ClockLogic.updateHash(state);
        render();
      });
    }

    // Helper to set up mutually exclusive button groups
    function setupButtonGroup(buttons, callback) {
      for (let i = 0; i < buttons.length; i++) {
        buttons[i].addEventListener('click', function() {
          for (let j = 0; j < buttons.length; j++) {
            buttons[j].classList.remove('active');
          }
          this.classList.add('active');
          callback(this);
        });
      }
    }

    function selectButton(buttons, dataAttr, value) {
      for (let i = 0; i < buttons.length; i++) {
        buttons[i].classList.remove('active');
        if (buttons[i].dataset[dataAttr] === String(value)) {
          buttons[i].classList.add('active');
        }
      }
    }

    setupButtonGroup(el.modeBtns, function(btn) {
      state.mode = btn.dataset.mode;
      el.timeInput.placeholder = state.mode === 'end' ? 'hh:mm' : 'mins';
      el.timeInput.title = state.mode === 'end' ? 'End time (hh:mm, hhmm, or mm)' : 'Minutes (1-180)';
      ClockLogic.setCookie('clockMode', state.mode, 365);
      ClockLogic.updateHash(state);

      // Handle mode change
      if (state.running) {
        if (state.mode === 'end') {
          // Calculate and show end time when switching to END while running
          const now = new Date();
          const endDate = new Date(now.getTime() + state.remaining * 60000);
          const h = endDate.getHours();
          const m = endDate.getMinutes();
          const s = endDate.getSeconds();
          el.timeInput.value = h + ':' + (m < 10 ? '0' : '') + m;
          state.endTime = m + s / 60; // Preserve seconds precision
          // No pause in END mode
          el.goBtn.disabled = true;
        } else {
          // Show remaining minutes when switching to CCW/CW while running
          el.timeInput.value = Math.ceil(state.remaining);
          state.endTime = null;
          // Enable pause in CCW/CW modes
          el.goBtn.disabled = false;
          el.goBtn.textContent = 'Pause';
          el.goBtn.title = 'Pause the timer';
        }
      } else if (state.mode === 'end' && !state.running && !state.paused && el.timeInput.value.trim()) {
        // Handle preview animation on mode change (only when not paused)
        const parsed = parseInput(el.timeInput.value.trim());
        if (parsed) {
          state.total = parsed.total;
          state.remaining = parsed.total;
          state.endTime = parsed.endTime;
          startPreviewAnimation();
        }
      } else {
        stopPreviewAnimation();
      }
      // Re-initialize clock face for CW mode label mirroring
      initClockFace();
      render();
    });

    setupButtonGroup(el.markBtns, function(btn) {
      state.marks = parseInt(btn.dataset.marks);
      ClockLogic.setCookie('clockMarks', state.marks, 365);
      ClockLogic.updateHash(state);
      initClockFace();
      render();
    });

    function switchToEndMode() {
      if (state.mode !== 'end') {
        state.mode = 'end';
        selectButton(el.modeBtns, 'mode', 'end');
        el.timeInput.placeholder = 'hh:mm';
      }
    }

    el.timeInput.addEventListener('input', function(e) {
      const value = e.target.value.trim();
      el.goBtn.disabled = !value;

      // Update state and URL hash with time value
      state.timeValue = value;
      ClockLogic.updateHash(state);

      // Reset button when user types - stop any running timer
      if (state.running) {
        state.running = false;
        if (state.animFrame !== null) {
          cancelAnimationFrame(state.animFrame);
          state.animFrame = null;
        }
        if (timerWorker) timerWorker.postMessage({ type: 'stop' });
        document.body.classList.remove('running');
        el.goBtn.classList.remove('running');
        ClockLogic.releaseWakeLock();
        updateTitle();
      }
      state.paused = false;
      el.goBtn.textContent = 'Go';
      el.goBtn.title = 'Start the timer';

      // Stop completion blink when user types
      stopCompletionBlink();

      // Auto-switch to END mode on 4-digit input or colon (when in CCW/CW)
      if (state.mode !== 'end' && !state.running) {
        if (value.includes(':') || (value.length >= 4 && /^\d+$/.test(value))) {
          switchToEndMode();
        }
      }

      // Live preview: update clock face as user types (only when not running)
      if (!state.running) {
        if (value) {
          const parsed = parseInput(value);
          if (parsed) {
            state.total = parsed.total;
            state.remaining = parsed.total;
            state.endTime = parsed.endTime;
            // Start preview animation in END mode
            if (state.mode === 'end') {
              startPreviewAnimation();
            }
          } else {
            state.remaining = 0;
            stopPreviewAnimation();
          }
        } else {
          state.remaining = 0;
          stopPreviewAnimation();
        }
        render();
      }
    });

    el.timeInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter' && e.target.value.trim()) {
        start();
      }
    });

    el.goBtn.addEventListener('click', handleGoClick);

    // Load preferences from cookies and URL hash
    (function loadPreferences() {
      // First load from cookies
      var savedColor = ClockLogic.getCookie('clockColor');
      if (savedColor && /^#[0-9a-fA-F]{6}$/.test(savedColor)) {
        state.color = savedColor;
      }

      var savedMode = ClockLogic.getCookie('clockMode');
      if (savedMode && ['ccw', 'cw', 'end'].indexOf(savedMode) !== -1) {
        state.mode = savedMode;
      }

      var savedMarks = ClockLogic.getCookie('clockMarks');
      if (savedMarks !== null) {
        var marksVal = parseInt(savedMarks);
        if ([0, 5, 15].indexOf(marksVal) !== -1) {
          state.marks = marksVal;
        }
      }

      var savedDarkMode = ClockLogic.getCookie('clockDarkMode');
      if (savedDarkMode === '1') {
        document.body.classList.add('dark');
        el.darkModeBtn.textContent = '‚òÄÔ∏è';
        el.darkModeBtn.title = 'Switch to light mode';
      }

      var savedSound = ClockLogic.getCookie('clockSound');
      if (savedSound === 'on') {
        state.sound = true;
        el.soundBtn.textContent = 'üîî';
        el.soundBtn.title = 'Turn alarm off';
      }

      var savedDisplayMode = ClockLogic.getCookie('clockDisplayMode');
      if (savedDisplayMode === 'digital') {
        state.displayMode = 'digital';
        el.displayModeBtn.textContent = 'üïê';
        el.displayModeBtn.title = 'Switch to analog display';
      }

      // Then override with URL hash (URL takes priority)
      var hashParams = ClockLogic.parseHash();
      if (hashParams.color && /^[0-9a-fA-F]{6}$/.test(hashParams.color)) {
        state.color = '#' + hashParams.color;
      }
      if (hashParams.mode && ['ccw', 'cw', 'end'].indexOf(hashParams.mode) !== -1) {
        state.mode = hashParams.mode;
      }
      if (hashParams.marks !== undefined) {
        var marksVal = parseInt(hashParams.marks);
        if ([0, 5, 15].indexOf(marksVal) !== -1) {
          state.marks = marksVal;
        }
      }
      if (hashParams.dark === '1') {
        document.body.classList.add('dark');
        el.darkModeBtn.textContent = '‚òÄÔ∏è';
        el.darkModeBtn.title = 'Switch to light mode';
      }
      if (hashParams.sound === 'on') {
        state.sound = true;
        el.soundBtn.textContent = 'üîî';
        el.soundBtn.title = 'Turn alarm off';
      }
      if (hashParams.display === 'digital') {
        state.displayMode = 'digital';
        el.displayModeBtn.textContent = 'üïê';
        el.displayModeBtn.title = 'Switch to analog display';
      }
      if (hashParams.time) {
        // Validate time parameter: only allow digits, colon, and decimal point
        var sanitizedTime = hashParams.time.replace(/[^\d:.]/g, '');
        if (sanitizedTime && sanitizedTime.length <= 10) {
          el.timeInput.value = sanitizedTime;
          state.timeValue = sanitizedTime;
          // Parse input to set state.total/remaining (same as input handler)
          var parsed = ClockLogic.parseInput(sanitizedTime, state.mode, new Date(), MAX_MINUTES);
          if (parsed) {
            state.total = parsed.total;
            state.remaining = parsed.total;
            state.endTime = parsed.endTime;
            el.goBtn.disabled = false;
          }
        }
      }

      // Apply mode to UI
      for (var i = 0; i < el.modeBtns.length; i++) {
        el.modeBtns[i].classList.remove('active');
        if (el.modeBtns[i].dataset.mode === state.mode) {
          el.modeBtns[i].classList.add('active');
        }
      }
      el.timeInput.placeholder = state.mode === 'end' ? 'hh:mm' : 'mins';

      // Apply marks to UI
      for (var i = 0; i < el.markBtns.length; i++) {
        el.markBtns[i].classList.remove('active');
        if (parseInt(el.markBtns[i].dataset.marks) === state.marks) {
          el.markBtns[i].classList.add('active');
        }
      }

      // Request notification permission immediately if sound is enabled
      if (state.sound) {
        ClockLogic.requestNotificationPermission();
      }

      // Hide controls if requested via URL (for automated screenshots)
      if (hashParams.controls === '0') {
        document.querySelector('.controls').style.display = 'none';
      }

      // Autostart timer if requested via URL (for automated screenshots)
      if (hashParams.autostart === '1' && !el.goBtn.disabled) {
        el.goBtn.click();
      }
    })();

    // Dark mode toggle
    el.darkModeBtn.addEventListener('click', function() {
      document.body.classList.toggle('dark');
      var isDark = document.body.classList.contains('dark');
      el.darkModeBtn.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
      el.darkModeBtn.title = isDark ? 'Switch to light mode' : 'Switch to dark mode';
      // Update PWA theme color to match mode
      var themeColor = document.querySelector('meta[name="theme-color"]');
      if (themeColor) themeColor.setAttribute('content', isDark ? '#111' : '#f9fafb');
      ClockLogic.setCookie('clockDarkMode', isDark ? '1' : '0', 365);
      ClockLogic.updateHash(state);
      initClockFace();
    });

    // Sound toggle
    el.soundBtn.addEventListener('click', function() {
      state.sound = !state.sound;
      el.soundBtn.textContent = state.sound ? 'üîî' : 'üîï';
      el.soundBtn.title = state.sound ? 'Turn alarm off' : 'Turn alarm on';
      ClockLogic.setCookie('clockSound', state.sound ? 'on' : 'off', 365);
      ClockLogic.updateHash(state);
      // Request notification permission when sound is enabled
      if (state.sound) {
        ClockLogic.requestNotificationPermission();
      }
    });

    // Display mode toggle (analog/digital)
    el.displayModeBtn.addEventListener('click', function() {
      state.displayMode = state.displayMode === 'analog' ? 'digital' : 'analog';
      var isDigital = state.displayMode === 'digital';
      el.displayModeBtn.textContent = isDigital ? 'üïê' : 'üî¢';
      el.displayModeBtn.title = isDigital ? 'Switch to analog display' : 'Switch to digital display';
      ClockLogic.setCookie('clockDisplayMode', state.displayMode, 365);
      ClockLogic.updateHash(state);
      render();
    });

    // Focus trap for modals
    function trapFocus(modal, e) {
      if (e.key !== 'Tab') return;
      var focusable = modal.querySelectorAll('a[href], button, input, [tabindex]:not([tabindex="-1"])');
      var first = focusable[0];
      var last = focusable[focusable.length - 1];
      if (e.shiftKey && document.activeElement === first) {
        e.preventDefault();
        last.focus();
      } else if (!e.shiftKey && document.activeElement === last) {
        e.preventDefault();
        first.focus();
      }
    }

    // Info modal
    el.infoBtn.addEventListener('click', function() {
      el.infoModal.classList.add('show');
      el.infoCloseBtn.focus();
    });

    el.infoCloseBtn.addEventListener('click', function() {
      el.infoModal.classList.remove('show');
      el.infoBtn.focus();
    });

    el.infoModal.addEventListener('click', function(e) {
      if (e.target === el.infoModal) {
        el.infoModal.classList.remove('show');
        el.infoBtn.focus();
      }
    });

    el.infoModal.addEventListener('keydown', function(e) {
      trapFocus(el.infoModal, e);
    });

    // Install instructions modal
    el.installLink.addEventListener('click', function(e) {
      e.preventDefault();
      el.infoModal.classList.remove('show');
      el.installModal.classList.add('show');
      el.installCloseBtn.focus();
    });

    el.installCloseBtn.addEventListener('click', function() {
      el.installModal.classList.remove('show');
      el.infoBtn.focus();
    });

    el.installModal.addEventListener('click', function(e) {
      if (e.target === el.installModal) {
        el.installModal.classList.remove('show');
        el.infoBtn.focus();
      }
    });

    el.installModal.addEventListener('keydown', function(e) {
      trapFocus(el.installModal, e);
    });

    // Fullscreen toggle
    el.fullscreenBtn.addEventListener('click', function() {
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen();
      } else if (document.documentElement.webkitRequestFullscreen) {
        document.documentElement.webkitRequestFullscreen();
      }
      document.body.classList.add('fullscreen');
    });

    el.exitFullscreenBtn.addEventListener('click', function() {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      }
      document.body.classList.remove('fullscreen');
    });

    // Sync fullscreen class when user exits via Escape key
    document.addEventListener('fullscreenchange', function() {
      if (!document.fullscreenElement) {
        document.body.classList.remove('fullscreen');
      }
    });

    // Picture-in-Picture functionality
    var pipState = { active: false, stream: null };
    var PIP_RADIUS = { FULL: 140, MIDDLE: 93, INNER: 47 };

    function renderToCanvas() {
      var canvas = el.pipCanvas;
      var ctx = canvas.getContext('2d');
      var size = 300;
      var center = size / 2;
      var maxRadius = 140;

      // Clear canvas
      var isDark = document.body.classList.contains('dark');
      ctx.fillStyle = isDark ? '#111' : '#fff';
      ctx.fillRect(0, 0, size, size);

      // Draw clock face circle
      ctx.beginPath();
      ctx.arc(center, center, maxRadius, 0, Math.PI * 2);
      ctx.strokeStyle = isDark ? '#fff' : '#000';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Handle completion blink
      if (state.completed) {
        // Pulse animation: opacity oscillates between 0 and 1 over 2 seconds
        var blinkPhase = (Date.now() % 2000) / 2000;
        var blinkOpacity = Math.abs(Math.sin(blinkPhase * Math.PI));

        ctx.beginPath();
        ctx.arc(center, center, maxRadius, 0, Math.PI * 2);
        ctx.globalAlpha = blinkOpacity;
        ctx.fillStyle = state.color;
        ctx.fill();
        ctx.globalAlpha = 1;
      } else {
        // Draw wedges using state.remaining (works for both preview and running)
        var time = state.remaining;
        if (time > 0) {
          var circles = ClockLogic.getCircles(time, PIP_RADIUS);

          circles.forEach(function(c) {
            var circleRadius = c.r;
            var darkenFactor = c.r === PIP_RADIUS.INNER ? 0.5 : (c.r === PIP_RADIUS.MIDDLE ? 0.7 : 1);
            var color = c.full ? ClockLogic.darken(state.color, darkenFactor) : state.color;

            if (c.full) {
              ctx.beginPath();
              ctx.arc(center, center, circleRadius, 0, Math.PI * 2);
              ctx.fillStyle = color;
              ctx.fill();
            } else {
              var startAngle, endAngle;
              if (state.mode === 'cw') {
                startAngle = ((60 - c.t) / 60) * Math.PI * 2 - Math.PI / 2;
                endAngle = -Math.PI / 2;
              } else if (state.mode === 'end') {
                var now = new Date();
                var curMin = now.getMinutes() + now.getSeconds() / 60;
                startAngle = (curMin / 60) * Math.PI * 2 - Math.PI / 2;
                endAngle = (state.endTime / 60) * Math.PI * 2 - Math.PI / 2;
              } else {
                startAngle = -Math.PI / 2;
                endAngle = (c.t / 60) * Math.PI * 2 - Math.PI / 2;
              }
              ctx.beginPath();
              ctx.moveTo(center, center);
              ctx.arc(center, center, circleRadius, startAngle, endAngle);
              ctx.closePath();
              ctx.fillStyle = color;
              ctx.fill();
            }
          });
        }
      }

      // Draw tick marks
      for (var i = 0; i < 60; i++) {
        var angle = (i / 60) * Math.PI * 2 - Math.PI / 2;
        var isMajor = i % 5 === 0;
        var innerR = maxRadius * (isMajor ? 0.85 : 0.9);
        var outerR = maxRadius * 0.95;
        ctx.beginPath();
        ctx.moveTo(center + innerR * Math.cos(angle), center + innerR * Math.sin(angle));
        ctx.lineTo(center + outerR * Math.cos(angle), center + outerR * Math.sin(angle));
        ctx.strokeStyle = isDark ? '#fff' : '#000';
        ctx.lineWidth = isMajor ? 2 : 1;
        ctx.stroke();
      }
    }

    function updatePip() {
      if (pipState.active) {
        renderToCanvas();
        // Use setTimeout at 30fps to match captureStream(30) rate, saves CPU
        setTimeout(updatePip, 33);
      }
    }

    function startPip() {
      renderToCanvas();

      // Create stream from canvas
      pipState.stream = el.pipCanvas.captureStream(30);
      el.pipVideo.srcObject = pipState.stream;
      el.pipVideo.play().then(function() {
        // Try standard API first, then Safari
        if (el.pipVideo.requestPictureInPicture) {
          el.pipVideo.requestPictureInPicture().then(function() {
            pipState.active = true;
            updatePip();
          }).catch(function(err) {
            console.error('PiP failed:', err);
          });
        } else if (el.pipVideo.webkitSetPresentationMode) {
          el.pipVideo.webkitSetPresentationMode('picture-in-picture');
          pipState.active = true;
          updatePip();
        }
      });
    }

    el.pipBtn.addEventListener('click', function() {
      if (pipState.active) {
        if (document.exitPictureInPicture) {
          document.exitPictureInPicture();
        } else if (el.pipVideo.webkitSetPresentationMode) {
          el.pipVideo.webkitSetPresentationMode('inline');
        }
        return;
      }

      startPip();
    });

    el.pipVideo.addEventListener('leavepictureinpicture', function() {
      pipState.active = false;
      if (pipState.stream) {
        pipState.stream.getTracks().forEach(function(track) { track.stop(); });
        pipState.stream = null;
      }
      el.pipVideo.srcObject = null;
    });

    // Safari PiP event
    el.pipVideo.addEventListener('webkitpresentationmodechanged', function() {
      if (el.pipVideo.webkitPresentationMode !== 'picture-in-picture') {
        pipState.active = false;
        if (pipState.stream) {
          pipState.stream.getTracks().forEach(function(track) { track.stop(); });
          pipState.stream = null;
        }
        el.pipVideo.srcObject = null;
      }
    });

    // Preset buttons - click to immediately start timer
    var presetBtns = document.querySelectorAll('.preset-btn');
    for (var i = 0; i < presetBtns.length; i++) {
      presetBtns[i].title = 'Start ' + presetBtns[i].dataset.preset + ' minute timer';
      presetBtns[i].setAttribute('aria-label', 'Start ' + presetBtns[i].dataset.preset + ' minute timer');
      presetBtns[i].addEventListener('click', function() {
        var btn = this;
        btn.classList.add('pressed');
        setTimeout(function() {
          btn.classList.remove('pressed');
        }, 50);
        el.timeInput.value = this.dataset.preset;
        el.timeInput.dispatchEvent(new Event('input'));
        start();
      });
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
      // Ignore if typing in input field
      if (document.activeElement === el.timeInput) return;

      if (e.code === 'Space') {
        e.preventDefault();
        // No pause/resume in END mode
        if (state.mode === 'end') return;
        if (state.running) pause();
        else if (state.paused) resume();
      } else if (e.code === 'KeyF') {
        e.preventDefault();
        if (document.fullscreenElement) {
          document.exitFullscreen();
        } else if (document.documentElement.requestFullscreen) {
          document.documentElement.requestFullscreen();
          document.body.classList.add('fullscreen');
        }
      } else if (e.code === 'Escape') {
        if (el.installModal.classList.contains('show')) {
          el.installModal.classList.remove('show');
        } else if (el.infoModal.classList.contains('show')) {
          el.infoModal.classList.remove('show');
        } else if (document.fullscreenElement) {
          document.exitFullscreen();
        }
      } else if (e.code === 'KeyP') {
        e.preventDefault();
        el.pipBtn.click();
      }
    });

    // Controls visibility - pure JS (no CSS class juggling)
    var clockContainer = document.querySelector('.clock-container');
    var controls = document.querySelector('.controls');
    var isTouchDevice = 'ontouchstart' in window;
    var controlsVisible = true;
    var clickShowActive = false; // Browser: clicked to show, waiting for hover to release

    function setControlsVisible(visible) {
      if (!controls) return;
      controls.style.opacity = visible ? '1' : '0';
      // Touch: block events when hidden. Browser: keep events so hover works.
      if (isTouchDevice) {
        controls.style.pointerEvents = visible ? 'auto' : 'none';
      }
      controlsVisible = visible;
    }

    function resetControls() {
      if (!controls) return;
      controls.style.opacity = '';
      controls.style.pointerEvents = '';
      controlsVisible = true;
      clickShowActive = false;
    }

    // Watch for timer start/stop
    var bodyObserver = new MutationObserver(function(mutations) {
      if (!document || !document.body) return;
      mutations.forEach(function(mutation) {
        if (mutation.attributeName === 'class') {
          if (document.body.classList.contains('running')) {
            // Timer started - hide controls after delay
            setTimeout(function() { setControlsVisible(false); }, 500);
          } else {
            // Timer stopped - show controls
            resetControls();
          }
        }
      });
    });
    if (document.body) {
      bodyObserver.observe(document.body, { attributes: true });
    }

    if (isTouchDevice) {
      // Touch: tap clock to toggle controls
      clockContainer.addEventListener('touchend', function(e) {
        if (!state.running) return;
        if (e.changedTouches.length !== 1) return;
        if (controlsVisible) {
          setControlsVisible(false);
        } else {
          e.preventDefault();
          setControlsVisible(true);
        }
      });

      // Touch: tap on hidden controls area shows them first
      controls.addEventListener('touchend', function(e) {
        e.stopPropagation();
        if (!controlsVisible) {
          e.preventDefault();
          setControlsVisible(true);
        }
      });
    } else {
      // Browser: hover shows/hides controls
      controls.addEventListener('mouseenter', function() {
        if (!state.running) return;
        if (clickShowActive) {
          // Release click-show mode, now in normal hover mode
          clickShowActive = false;
        }
        setControlsVisible(true);
      });

      controls.addEventListener('mouseleave', function() {
        if (!state.running) return;
        setControlsVisible(false);
      });

      // Browser: click on clock to toggle controls
      clockContainer.addEventListener('click', function(e) {
        if (!state.running) return;
        // Ignore if click was inside controls
        if (controls.contains(e.target)) return;

        if (controlsVisible) {
          setControlsVisible(false);
          clickShowActive = false;
        } else {
          setControlsVisible(true);
          clickShowActive = true;
        }
      });
    }

    // Re-request wake lock when page becomes visible again
    document.addEventListener('visibilitychange', function() {
      if (!document.hidden && state.running && !state.paused) {
        ClockLogic.requestWakeLock();
      }
    });

    // Clean up resources on page unload
    window.addEventListener('beforeunload', function() {
      // Disconnect mutation observer to prevent errors during cleanup
      if (bodyObserver) {
        bodyObserver.disconnect();
        bodyObserver = null;
      }
      if (state.animFrame) {
        cancelAnimationFrame(state.animFrame);
        state.animFrame = null;
      }
      if (state.previewFrame) {
        cancelAnimationFrame(state.previewFrame);
        state.previewFrame = null;
      }
      if (state.overtimeInterval) {
        clearInterval(state.overtimeInterval);
        state.overtimeInterval = null;
      }
      if (timerWorker) {
        timerWorker.postMessage({ type: 'stop' });
      }
      ClockLogic.releaseWakeLock();
      ClockLogic.stopAlarm(state.alarmHandle);
    });

    el.colorBtn.style.background = state.color;
    // Update PWA theme color to match dark/light mode
    var themeColorMeta = document.querySelector('meta[name="theme-color"]');
    if (themeColorMeta) {
      var isDark = document.body.classList.contains('dark');
      themeColorMeta.setAttribute('content', isDark ? '#111' : '#f9fafb');
    }
    // Only disable Go button if no time was loaded from URL
    if (!state.total) {
      el.goBtn.disabled = true;
    }
    el.goBtn.title = 'Start the timer';
    el.timeInput.title = state.mode === 'end' ? 'End time (hh:mm, hhmm, or mm)' : 'Minutes (1-180)';

    // Hide PiP button if not supported (Safari doesn't support canvas-to-PiP)
    // Detect Safari (but not Chrome on iOS which also has Safari UA)
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (isSafari || !el.pipCanvas.captureStream || !el.pipVideo.requestPictureInPicture) {
      el.pipBtn.style.display = 'none';
    }

    initClockFace();
    render();
    el.timeInput.focus();
  </script>
</body>
</html>
